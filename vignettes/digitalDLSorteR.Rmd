---
title: "digitalLDSorteR: R package for deconvolution of bulk RNA-Seq samples based on Deep Learning"
author:
- name: First Author
  affiliation: First Author's Affiliation
- name: Second Author
  affiliation: Second Author's Affiliation
  email: corresponding@author.com
package: digitalDLSorteR
output:
  BiocStyle::html_document
    # css: "./css/style.css"
    toc: true
    toc_float: true
abstract: |
  Introduction of main functionalities of digitalDLSorteR. This package has two goals. Firstly, to offer a set of pre-trained deconvolution models for the prediction of cell composition in bulk RNA-seq samples quickly and easily. Secondly, digitalDLSorteR provides all the necessary functions for the construction of new deconvolution models from scRNA-seq data. In this vignette, both ways of use are explained with examples built into the package. 
vignette: |
  %\VignetteIndexEntry{digitalLDSorteR: R package for deconvolution of bulk RNA-Seq samples based on Deep Learning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignettePackage{digitalDLSorteR}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
options(width = 70)
require(BiocStyle)
```


# Introduction to `digitalDLSorteR`package

digitalDLSorteR is a R package that implements a Deep Learning based method to 
enumerate and quantify the cell type composition of bulk RNA-Seq samples. Our 
method makes use of a Deep Neural Network (DNN) model to adjust any cell type
composition defined from a single-cell RNA-Seq (scRNA-Seq) data. 

The method is based on a pipeline that starts from scRNA-Seq data and, after a few
steps, a Deep Neural Network (DNN) model is trained with simulated bulk RNA-seq 
samples whose cell composition is known. The trained model is able to 
deconvolute any bulk RNA-seq sample determining the proportion of the 
different cell types present in it. The main advantage of this method is the
possibility of building deconvolution models trained with real data which comes
from certain biological environments. For example, for quantifying the proportion
of TILs in breast cancer, following this protocol you can obtain a specific model
for this type of samples. This fact overcomes the limitation of other methods,
since stromal and immune cells change significantly their profiles depending on
the tissue and disease context. 

The package can be used in two ways: for deconvoluting bulk RNA-seq
samples using a pre-trained model provided by us or for building your own models
trained from your own scRNA-seq samples with its own peculiarities. These 
new models can be published in order to make them available for other users
that work with similar data (e.g. neural environment, prostate cancer environment,
etc). For the moment, the available models allows the deconvolution of tumor
infiltrated lymphocytes (TILs) from breast cancer classified by our team.


# Using pre-trained models for deconvoluting bulk RNA-seq samples

This is the simplest way to use the method. Only it is necessary a bulk RNA-seq
sample matrix with genes as rows (in symbol notation) and samples as columns and
the package returns the predicted cell composition of each sample. As mentioned
above, for the moment, only one model for deconvoluting breast cancer samples is
available. This model was generated from GSE75688 (Chung et al., 2017) data set
whose cells were characterized by our team. It is oriented to the quantification
of immune cell types in cancer samples. It presents advantages over other tools,
since it has been trained from scRNA-Seq data from the tumor itself, preserving
the specific characteristics of the tumor microenvironment as opposite to other
approaches in which cells were isolated from blood. 

Moreover, we have provided two resolution levels for the deconvolution task:

* First, a model trained with cell types characterized at high resolution level:
ER+, HER2+, ER+/HER2+, TNBC, stromal, monocyte, TCD4mem (memory CD4+ T cells), 
BGC (germinal center B cells), Bmem (memory B cells), DC (dendritic cells),
macrophage, TCD8 (CD8+ T cells) and TCD4reg (regulatory CD4+ T cells).

* Second, a model trained with cell types less specific: B cells, T CD4+ cells,
T CD8+ cells, monocytes, dendritic cells, stromal cells and tumor cells.

For more information about the data set, see the provided documentation in the
package. 

## Example of the use of the package

Using the package in this way, it is only necessary to load the samples that you
want to deconvolute in R and use them as `data` argument for 
`deconvDigitalDLSorter` function. This object must be a `matrix` or a `data.frame`
with genes as rows and samples as columns. Genes must be annotated as SYMBOL, 
since the model was trained with this notation. Data must be TPMs, since model
was trained with this type of data. If data are not normalize, set `normalize`
argument equal to `TRUE` (by default). Moreover, you must specify the model that 
will be used in `model` argument. In this example, we are going to deconvolute a 
small subset of TCGA samples from breast sample. We are using the generic version 
(`model = "breast.chung.generic"`), but it is also possible the use of a 
specific (`model = "breast.chung.specific"`):

```{r deconvoluteTCGA}
library(digitalDLSorteR)

tensorflow::tf$compat$v1$disable_eager_execution()

deconvResults <- deconvDigitalDLSorter(
  data = TCGA.breast.small,
  model = "breast.chung.generic",
  normalize = TRUE
)

head(deconvResults)
```

`deconvDigitalDLSorter` returns a data frame with the provided samples ($i$) in 
rows and cell types considered by the model ($j$) in columns. Each entry 
corresponds with the proportion of $j$ cell type in $i$ sample. In order to 
evaluate the results quickly by a barplot, you can use the function 
`barplotCellTypes` as follows:

```{r resultsDeconvTCGA, fig.height=8, fig.width=8}
barPlotCellTypes(
  deconvResults, 
  rm.x.text = TRUE,
  color.line = "black",
  title = "Results of deconvolution of TCGA breast samples"
)
```

# Build your own model for deconvolution of bulk RNA-Seq samples in a determined 
environment

`digitalDLSorteR` allows to train new models from different scRNA-Seq data 
in order to offer the possibility to generate models more suitable for 
determined biological environments. For this, the steps described in the 
following pipeline must be followed. As example, we are going to generate a 
'toy' model from scRNA-seq data used for building the `breast.chung` model 
available in the package. 


## Load data into a `DigitalDLSorter` object

First, we have to load data into a 'DigitalDLSorter` object, the core of the 
package. This S4 class contains all slots necessaries for storing the different 
data generated during the building of the model. The 
information that you must provided consists in three elements: 

* Single-cell counts: a matrix with genes in rows and cells in columns.
* Cells metadata: a table with annotations (columns) for each cell (rows). The 
information expected in this element are metadata that could be used as 
covariates in the next steps (gender, type of sample...), a column with the 
ID used for each cell and a column with the corresponding cell type.
* Genes metadata with annotations (columns) for each gene (rows). In the same 
way that in cells metadata, the information that is expected in this element 
are a column with the notation used for each gene in counts matrix and others 
covariates like gene length. You can inspect the `sc.chung.breast` object to 
see the required structure.^[Data used for the examples are stored into the package as a 
`SingleCellExperiment` object. This object contains the results of different 
steps in order to avoid some steps whose execution is extensive, specifically 
the estimation of new scRNA-seq profiles]

If your data contains a low number of cells or some cell types are poorly 
represented, you must load data with `loadRealSCProfiles` function. Data is loaded
into `single.cell.real` slot for estimating parameters in order to simulate new 
single-cell profiles (see the following steps). If your data does not present 
this features and it is not necessary the simulation of new single-cell profiles, 
you can use `loadFinalSCProfiles`, that loads data into `single.cell.final` slot. 
In this vignette, we are going to present the large protocol.

```{r loadData}
DDLSChung <- loadRealSCProfiles(
  single.cell.real = sc.chung.breast,
  cell.ID.column = "Cell_ID",
  gene.ID.column = "external_gene_name",
  min.cells = 0,
  min.counts = 0,
  project = "Chung_etal_2017"
)
```
In this case, we are loading single-cell profiles from a `SingleCellExperiment` 
object, but it is also possible to load it from tsv files and sparse matrices. 
The code would be as follows (this box-code will not be run):

```{r loadFromFile, eval = FALSE}
## this code will not be run
filesChung <- c("countsMatrix.tsv.gz",
                "cellsMetadata.tsv.gz",
                "genesMetadata.tsv.gz")

DDLSChung <- loadRealSCProfiles(
  single.cell.real = filesChung,
  cell.ID.column = "Cell_ID",
  gene.ID.column = "external_gene_name",
  min.cells = 0,
  min.counts = 0,
  project = "Chung_etal_2017"
)
```

## Estimation of parameters of ZINB-WaVE model for simulating new single-cell 
profiles

If data is loaded into `single.cell.real` slot, new simulated single-cell profiles
based on real profiles will be generated. The goal is the oversampling of low
frequency cell types in order to increase their signal and 
train the model in a balanced way. For this, digitalDLSorteR uses the
ZINB-WaVE framework () to estimate the parameters of a ZINB (zero-inflated 
negative binomial) distribution to simulate new single-cell profiles. This 
model was chosen due to its ability to accommodate not only the variability 
within a particular cell type but also the variability within the whole 
experiment. 

The process is performed by `estimateZinbwaveParams` function. It implements 
the ZINB-WaVE model by using `r Biocpkg("splatter")` package, a wrapper of 
`r Biocpkg("zinbwave")` package. You must specify the column in cells metadata
that corresponds with cell types. Moreover, you can add cell covariates based 
on your experimental design such as patient or gender and gene covariates such 
as gene length. This process may take a few minutes to run because it 
is poorly optimized in the original packages, so be patient. For this vignette, 
ZINB-WaVE model is loaded from digitalDLSorteR package in order to avoid the 
wait. In any case, you can adjust the number of threads to use in some steps 
of the estimation with `threads` argument. It is used for this proposal 
`r Biocpkg("BiocParallel")` package. 

```{r zinbwaveEstimation, eval=FALSE}
## this code will not be run
DDLSChung <- estimateZinbwaveParams(
  object = DDLSChung,
  cell.ID.column = "Cell_ID",
  gene.ID.column = "external_gene_name",
  cell.type.column = "Cell_type",
  cell.cov.columns = "Patient",
  gene.cov.columns = "gene_length",
  threads = 4,
  verbose = TRUE
)
```

The resulting model is stored in `zinb.params` slot. You can access with its getter function:

```{r}
zinb.params(DDLSChung)
```


## Simulate new single-cell profiles using the estimated parameters

Once ZINB-WaVE parameters are estimated, `simSingleCellProfiles` function uses 
them for simulating new single-cell profiles based on real single-cell profiles. 
The simulation is performed by randomly sampling from a negative binomial 
distribution with ZINB parameters estimated ($\mu$ and $\theta$) and introducing 
dropouts by sampling from a binomial distribution with estimated $\pi$ 
probability. You must specify the number of cell profiles per cell type that 
will be generated. For example, if your data set is composed by 10 cell types and 
`n.cells` is equal to 10, the number of simulated profiles will be 100. 

```{r}
DDLSChung <- simSingleCellProfiles(
  object = DDLSChung,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_type",
  n.cells = 10,
  verbose = TRUE
)
```

The resulting simulated data is stored in `single.cell.final` slot to be used
for the simulation of bulk RNA-seq profiles with known cell composition.


## Generate cell composition matrix for bulk simulated expression profiles

For simulating bulk samples, first, it is necessary the generation of a cell 
composition matrix which determines the proportion of each cell type in each 
sample. It is carried out by `generateTrainAndTestBulkProbMatrix` function and 
the results are stored in `prob.cell.types` slot as a `ProbMatrixCellTypes` object. 

For this process, first, single-cell profiles are split in train and test 
data (see `train.freq`). This is because each subset of single-cell data will 
form each subset of bulk samples, avoiding the distortion of results. Then, 
proportions are generated by five different methods in order to avoid biases 
during training due to the cell composition of simulated bulk NRA-seq samples:

1. Cell proportions are randomly sampled from a truncated uniform distribution
with predefined limits according to _a priori_ knowledge of the abundance 
of each cell type (see `prob.design` argument). This information ban be
inferred from the single cell analysis itself or from the literature.
2. A second set is generated by randomly permuting cell type labels from a
distribution generated by the previous method.
3. Cell proportions are randomly sampled as by method 1 without replacement.
4. Using the last method for generating proportions, cell types labels are 
randomly sampled.
5. Cell proportions are randomly sampled from a Dirichlet distribution.

The limits of each cell type according to _a priori_ knowledge 
are defined by a `data.frame` with the structure of `probMatrix` object in the 
following code. This information can be estimated from the single-cell 
experiment itself or from literature. You can specify the number of bulk 
samples that will be simulated with
`num.bulk.samples` argument (by default, approximately 18 more samples will be 
formed than there are cells in `single.cell.final` slot) and the proportion of 
bulk samples that will be generated by each method 
in train and test data with `proportions.train` and `proportions.test` arguments. 
By default, 85% of samples are generated by the methods that introduce the greatest 
randomness in the proportions (methods 2, 3, 4 and 5). The remaining samples are 
generated by the first method. 

```{r}
probMatrix <- data.frame(
  Cell_types = c("ER+", "HER2+", "ER+ and HER2+", "TNBC",
                 "Stromal", "Monocyte", "Tme", "BGC",
                 "Bmem", "DC", "Macrophage", "TCD8", "Treg"),
  from = c(rep(30, 4), 1, rep(0, 8)),
  to = c(rep(70, 4), 50, rep(15, 8))
)

DDLSChung <- generateTrainAndTestBulkProbMatrix(
  object = DDLSChung,
  cell.type.column = "Cell_type",
  prob.design = probMatrix,
  num.bulk.samples = 200,
  verbose = TRUE
)
```

In this example, we are simulating the proportions of 200 bulk samples for 
avoid an excessive use of RAM in the following steps. In real circumstances, 
we recommend, depending on the number of starting
single-cell profiles and the available computational resources, about 30000 
samples and the default proportions. 

You can access to the distribution of proportions generated by each method using 
`showProbPlot` function. This function show different ways for visualizing this
information. In the following code, we are going to display the former and the 
last distributions of train samples:

```{r}
lapply(c(1, 6), function(x) {
  showProbPlot(DDLS.Chung.1,
               type.data = "train", set = x, type.plot = "boxplot")
})
```


## Simulate bulk RN-seq profiles with known cell composition

As in tissues the expression levels of each gene from a bulk RNA-seq experiment 
represent the summation of different cells, digitalDLSorteR simulates new 
profiles by adding the expression levels of each gene from single-cell profiles 
according to the proportions generated in the previous step. Therefore, the 
bulk matrix expression will be simulated according the Equation \#eq:bulk:


\begin{equation}
  T_{ij} = \sum_{k = 1}^{K} \sum_{z = 1}^Z C_{izk} 
  (\#eq:bulk)
\end{equation}

\begin{equation*}
  \arraycolsep=1.4pt\def\arraystretch{1.3}
  \textrm{de forma que} \left\{
\begin{array}{l}
  i = 1 \ldots M;\\
  j = 1 \ldots N \\
  Z = 1 \ldots 100 \cdot P_{kj} \\
  \sum_{k = 1}^K Z \cdot P_{kj} = 100
\end{array}
\right.  
\end{equation*}

where $T_{ij}$ is the expression level of $i$ gene in $j$ bulk sample; $C_{izk}$
is the expression level of $i$ gene in $z$ cell in $j$ bulk sample; and 
$P_{kj}$ is the proportion of $k$ cell type in $j$ bulk sample (the cell 
composition matrix generated in the preious step). $Z$ represents the number of 
cells that will compound the proportion of $k$ cell type in $j$ bulk sample. 
These cells are randomly sampled based on their cell type. Finally, each bulk 
sample will be form by 100 cells. 

This step is carried out by `generateBulkSamples` function as shown in the 
following code box:

```{r generateBulkSamples}
DDLSChung <- generateBulkSamples(
  DDLSChung,
  type.data = "both"
)
```

This way of use will load all bulk samples in -memory. If the number of bulk 
samples increases, It is possible to use HDF5 files as a back-end for storing 
data through packages `r Biocpkg("DelayedArray")` and `r Biocpkg("HDF5Array")`. 
These packages allows to store data on-disk while this data is accessible from R 
session dynamically. You will simulate large amounts of bulk samples in order 
to obtain a better deconvolution model. The use is the same as above but 
providing in `file.backend` argument a valid path to store HDF5 file. 
 
```{r eval=FALSE}
## this code will not be run
DDLSChung <- generateBulkSamples(
  DDLSChung,
  type.data = "both",
  file.backend = file.path(validFilePath, "bulk_simul_samples.h5")
)
```

We recommend this way of use because the training of deep neural network can be 
computationally heavy in terms of memory used. 


## Prepare data for training and evaluating the Deep Neural Network model

The next step consists in the preparation of data for training the Deep Neural 
Network model. You can specify which type of data will be used for training 
the model: only single-cell profiles, only bulk profiles or a combination of both. 
We recommend using bulk profiles or a combination, since the neural network works
better if samples consists in a combination of cell types with different 
proportions. In this way, the model is able to find patterns in the expression 
profiles that define each cell type.

Then, selected data is normalized (by computing CPMs and classic normalization), 
shuffled and transposed for its use as input in the neural network. It should 
be noted that, as in the previous step, it is possible to use HDF5Array files 
as back-end to store the samples that will be used for training.

```{r prepareDataForTraining}
DDLSChung <- prepareDataForTraining(
  object = DDLSChung,
  type.data = "both",
  combine = "bulk",
  verbose = TRUE
)
```


## Train and evaluate digitalDLSorter model

With data stored in `final.data` slot, Deep Neural Network will be trained 
and evaluated. This step is performed by `trainDigitalDLSorterModel` function and
uses `r CRANpkg("keras")` framework for all steps related qith Deep Learning. 
`r CRANpkg("keras")` package is an interface to keras module of Python for 
high level Deep Learning. If you want to know details about the architecture 
of the model and hyperparameters that presents, see Torroja and Sanchez-Cabo, 2019. 

The use is very simple, only is needed specify the number of epochs and the 
batch size used. In this example, we are going to use 5 epochs, but for a good 
training, you should test different values. With 20 epochs should be enough.

```{r}
DDLSChung <- trainDigitalDLSorterModel(
  object = DDLSChung,
  num.epochs = 5
)
```





# Getting started

To enable the _Bioconductor_ style in your R Markdown vignette you need to include the following in the `DESCRIPTION` file:

    VignetteBuilder: knitr
    Suggests: BiocStyle, knitr, rmarkdown


# Style macros

_BiocStyle_ introduces the following macros for referring to _R_ packages:

* `r Biocpkg("IRanges")`, for _Bioconductor_ software, annotation and experiment data packages,
* `r CRANpkg("data.table")`, for _R_ packages available on CRAN,
* `r Githubpkg("rstudio/rmarkdown")`, for _R_ packages available on GitHub,
* `r Rpackage("MyPkg")`, for _R_ packages that are _not_ available on _Bioconductor_, CRAN or GitHub.


# Figures

Assign captions to figures in the code chunk option `fig.cap` to automatically number them, and to be able to reference them, see Figure \@ref(fig:plot). The figure label is generated from the code chunk label by prefixing it with `fig:`.

```{r plot, fig.cap="Regular figure. The first sentence of the figure caption is automatically emphasized to serve as figure title.", echo=FALSE}
plot(cars)
```

Small and wide figures can be specified by `fig.small` and `fig.wide` code chunk options.

```{r small, fig.cap="Small figure. A plot produced by a code chunk with option `fig.small = TRUE`.", fig.small=TRUE, echo=FALSE}
plot(cars)
```

```{r wide, fig.cap="Wide figure. A plot produced by a code chunk with option `fig.wide = TRUE`.", fig.wide=TRUE, echo=FALSE}
plot(cars)
```


# Equations

To number and reference equations, put them in equation environments and assign labels to them, see Equation \@ref(eq:binom).

\begin{equation}
  f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}
  (\#eq:binom)
\end{equation}


# Tables

Like figures, tables with captions will also be numbered and can be referenced, see Table \@ref(tab:table).

Fruit   | Price
------- | -----
bananas | 1.2
apples  | 1.0
oranges | 2.5

: (\#tab:table) A simple table. With caption.


# Cross-references

Apart from referencing figures (Section \@ref(figures)), tables (Section \@ref(tables)), and equations (Section \@ref(equations)), you can also use the same syntax to refer to sections by their default labels generated by pandoc.


# Side notes

Footnotes are displayed as side notes on the right margin^[this is a side note entered as a footnote], which has the advantage that they appear close to the place where they are defined.


# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
