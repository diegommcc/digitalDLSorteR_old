
getProbMatrix <- function(object, type.data) {
  if (class(object) != "DigitalDLSorter") {
    stop("The object provided is not of DigitalDLSorter class")
  } else if (!any(type.data == c("train", "test"))) {
    stop("type.data argument must be 'train' or 'test'")
  }
  return(object@prob.cell.types[[type.data]]@prob.matrix)
}

#' Show probability plots generated with \code{\link{generateTrainAndTestBulkProbMatrix}}.
#'
#' Show probability plots generated with \code{\link{generateTrainAndTestBulkProbMatrix}}
#' by different methods that will determine the proportion of different cell types
#' used during the simulation of bulk RNA-Seq samples. There are 6 subsets
#' of probabilities generated by different approaches that can be shown with three
#' types of visualitations: boxplot, violinplot and linesplot.
#'
#' These plots are only for diagnostic purposes. This is the reason because they
#' are generated without any parameter introduced by the user.
#'
#' @param object \code{DigitalDLSorter} object with \code{prob.cell.types} slot
#' with \code{plot} slot.
#' @param type.data Subset of data to show: \code{train} or \code{test}.
#' @param set Integer determining which of the 6 different approaches used for
#'  generating the probability matrix show.
#' @param type.plot Character determining which type of visualitation show.
#' It can be \code{boxplot}, \code{violinplot}, \code{linesplot} or
#' \code{maxprob}.
#'
#' @return \code{ggplot} object.
#'
#' @export
#'
#' @seealso \code{\link{generateTrainAndTestBulkProbMatrix}}
#'
#' @examples
#' DDLSChung <- trainDigitalDLSorterModel(
#'   object = DDLSChung,
#'   batch.size = 128,
#'   num.epochs = 20
#' )
#'
showProbPlot <- function(
  object,
  type.data,
  set,
  type.plot = "maxprob"
) {
  if (class(object) != "DigitalDLSorter") {
    stop("The object provided is not of DigitalDLSorter class")
  } else if (is.null(object@prob.cell.types) | (length(object@prob.cell.types) == 0)) {
    stop("prob.cell.types slot is empty")
  } else if (!any(type.data == c("train", "test"))) {
    stop("type.data argument must be 'train' or 'test'")
  } else if (length(object@prob.cell.types[[type.data]]) == 0) {
    stop("ProbMatrixCellTypes object has not saved plots")
  } else if (set < 1 | set > 6) {
    stop("set argument must be a number from 1 to 6")
  } else if (!any(type.plot == c("violinplot", "boxplot", "linesplot", "maxprob"))) {
    stop("type.plot argument must be one of the next options: violinplot, boxplot, linesplot or maxprob")
  }
  return(object@prob.cell.types[[type.data]]@plots[[set]][[type.plot]])
}


.barPlot <- function(
  data,
  colors = color.list,
  color.line = NA,
  x.label = "Bulk samples",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90
) {
  df.res <- reshape2::melt(data * 100, value.name = "Proportion")

  p <- ggplot(data = df.res, aes(x = Var1, y = Proportion, fill = Var2)) +
    geom_bar(stat = "identity", color = color.line) + theme_classic()
  if (!is.null(colors)) {
    if (length(colors) < length(unique(df.res$Var2)))
      stop("Number of colors introduced is not enough to the number of cell types")
    p <- p + scale_fill_manual(values = colors)
  }
  if (is.null(x.label)) {
    p <- p + theme(axis.title.x = element_blank())
  } else {
    p <- p + labs(x = x.label)
  }
  p <- p + ggtitle(title) + labs(fill = legend.title) + theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text.x = element_text(angle = angle, hjust = 1, vjust = 0.5),
    legend.title = element_text(face = "bold")
  )
  if (rm.x.text) {
    p <- p + theme(axis.ticks.x = element_blank(),
                   axis.text.x = element_blank())
  }
  return(p)
}

#' Prepare \code{DigitalDLSorter} objects for saving as RDA file.
#'
#' Prepare \code{DigitalDLSorter} objects that have a \code{DigitalDLSorterDNN}
#' object with trained DNN model. \code{keras} models are not able to be stored
#' natively as R objects (e.g. RData or RDS files). By saving the structure as
#' JSON character object and weights as list object, it is possible recovering
#' the model and carrying out perdictions.
#'
#' With this option, the state of optimizer is not saved, only architecture and
#' weights. It is possible to save completely the model as HDF5 file with
#' \code{\link{saveTrainedModelAsH5}} function and to load into \code{DigitalDLSorter}
#' object with \code{\link{loadTrainedModelFromH5}} function.
#'
#' It is also possible to save a \code{DigitalDLSorter} object as RDS file with
#' \code{saveRDS} function without any type of previous preparation.
#'
#' @param object \code{\link{DigitalDLSorter}} object with \code{trained.data}
#' slot.
#'
#' @export
#'
#' @seealso \code{\link{saveRDS}} \code{\link{saveTrainedModelAsH5}}
#'
preparingToSave <- function(object) {
  if (class(object) != "DigitalDLSorter" ||
      class(object) != "DigitalDLSorterDNN") {
    stop("object provided is not a DigitalDLSorter object")
  }
  if (is.null(trained.model(object))) {
    message("Object provided has not a DigitalDLSorterDNN object. It is not necessary ",
            "prepare the object for saving on disk")
    return(object)
  } else if (is.null(trained.model(object)@model)) {
    message("Object provided has not a trained DNN model. It is not necessary ",
            "prepare the object for saving on disk")
    return(object)
  }
  if (class(trained.model(object)@model) == "list") return(object)
  else {
    trained.model.mod <- .saveModelToJSON(trained.model(object))
    trained.model(object) <- trained.model.mod
    return(object)
  }
}
