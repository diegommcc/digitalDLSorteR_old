#' Getter function for cell composition matrix.
#'
#' Getter function for cell composition matrix. This function allows you access
#' to the cell composition matrix of train or test bulk data.
#'
#' @param object \code{DigitalDLSorter} object with \code{prob.cell.types} slot.
#' @param type.data Subset of data to show: \code{train} or \code{test}.
#'
#' @return A \code{matrix} object.
#'
#' @export
#'
#' @seealso \code{\link{generateTrainAndTestBulkProbMatrix}}
#'
#'
getProbMatrix <- function(object, type.data) {
  if (class(object) != "DigitalDLSorter") {
    stop("The object provided is not of DigitalDLSorter class")
  } else if (!any(type.data == c("train", "test"))) {
    stop("type.data argument must be 'train' or 'test'")
  }
  return(object@prob.cell.types[[type.data]]@prob.matrix)
}

#' Show distribution plots of cell proportions generated by
#' \code{\link{generateTrainAndTestBulkProbMatrix}}.
#'
#' Show distribution plots of cell proportions generated by the five different
#' methods used by \code{\link{generateTrainAndTestBulkProbMatrix}}. These
#' frequencies will determine the proportion of different cell types used during
#' the simulation of bulk RNA-Seq samples. There are 6 subsets of proportions (1
#' and 2 are generated by the same way) by different approaches that can be
#' shown with three types of visualizations: boxplot, violinplot and linesplot.
#' You also can represent the probabilities based on the number of different
#' cell types present in samples setting \code{type.plot = 'nMix'}.
#'
#' These plots are only for diagnostic purposes. This is the reason because they
#' are generated without any parameter introduced by the user.
#'
#' @param object \code{DigitalDLSorter} object with \code{prob.cell.types} slot
#'   with \code{plot} slot.
#' @param type.data Subset of data to show: \code{train} or \code{test}.
#' @param set Integer determining which of the 6 different approaches used for
#'   generating the probability matrix show. Note that 1 and 2 follow the same
#'   distribution.
#' @param type.plot Character determining which type of visualization show. It
#'   can be \code{boxplot}, \code{violinplot}, \code{linesplot} or \code{nmix}.
#'   See Description for more information.
#'
#' @return \code{ggplot} object.
#'
#' @export
#'
#' @seealso \code{\link{generateTrainAndTestBulkProbMatrix}}
#'
#' @examples
#' lapply(1:6, function(x) {
#'   showProbPlot(DDLSSmallCompleted,
#'                type.data = "train",
#'                set = x,
#'                type.plot = "boxplot")
#' })
#'
showProbPlot <- function(
  object,
  type.data,
  set,
  type.plot = "boxplot"
) {
  if (class(object) != "DigitalDLSorter") {
    stop("The object provided is not of DigitalDLSorter class")
  } else if (is.null(object@prob.cell.types) | (length(object@prob.cell.types) == 0)) {
    stop("prob.cell.types slot is empty")
  } else if (!any(type.data == c("train", "test"))) {
    stop("type.data argument must be 'train' or 'test'")
  } else if (length(object@prob.cell.types[[type.data]]) == 0) {
    stop("ProbMatrixCellTypes object has not saved plots")
  } else if (set < 1 | set > 6) {
    stop("set argument must be a number from 1 to 6")
  } else if (!any(type.plot == c("violinplot", "boxplot", "linesplot", "nmix"))) {
    stop("type.plot argument must be one of the next options: violinplot, boxplot, linesplot or nmix")
  }
  return(object@prob.cell.types[[type.data]]@plots[[set]][[type.plot]])
}


#' Prepare \code{DigitalDLSorter} object for saving as RDA file.
#'
#' Prepare a \code{DigitalDLSorter} object that has a \code{DigitalDLSorterDNN}
#' object with trained DNN model. \code{keras} models are not able to be stored
#' natively as R objects (e.g. RData or RDS files). By saving the structure as
#' JSON character object and weights as list object, it is possible recovering
#' the model and carrying out predictions.
#'
#' With this option, the state of optimizer is not saved, only architecture and
#' weights.
#'
#' It is possible to save completely the model as HDF5 file with
#' \code{\link{saveTrainedModelAsH5}} function and to load into
#' \code{DigitalDLSorter} object with \code{\link{loadTrainedModelFromH5}}
#' function.
#'
#' It is also possible to save a \code{DigitalDLSorter} object as RDS file with
#' \code{saveRDS} function without any type of previous preparation.
#'
#' @param object \code{\link{DigitalDLSorter}} object with \code{trained.data}
#'   slot.
#'
#' @export
#'
#' @seealso \code{\link{saveRDS}} \code{\link{saveTrainedModelAsH5}}
#'
preparingToSave <- function(object) {
  if (class(object) != "DigitalDLSorter" ||
      class(object) != "DigitalDLSorterDNN") {
    stop("object provided is not a DigitalDLSorter object")
  }
  if (is.null(trained.model(object))) {
    message("Object provided has not a DigitalDLSorterDNN object. It is not necessary ",
            "prepare the object for saving on disk")
    return(object)
  } else if (is.null(trained.model(object)@model)) {
    message("Object provided has not a trained DNN model. It is not necessary ",
            "prepare the object for saving on disk")
    return(object)
  }
  if (class(trained.model(object)@model) == "list") return(object)
  else {
    trained.model.mod <- .saveModelToJSON(trained.model(object))
    trained.model(object) <- trained.model.mod
    return(object)
  }
}


.barPlot <- function(
  data,
  colors,
  color.line = NA,
  x.label = "Bulk samples",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90
) {
  df.res <- reshape2::melt(data * 100, value.name = "Proportion")

  p <- ggplot(data = df.res, aes(x = Var1, y = Proportion, fill = Var2)) +
    geom_bar(stat = "identity", color = color.line) + theme_classic()
  if (!missing(colors)) {
    if (length(colors) < length(unique(df.res$Var2)))
      stop("Number of colors introduced is not enough to the number of cell types")
  } else {
    colors <- color.list()
  }
  p <- p + scale_fill_manual(values = colors)
  if (is.null(x.label)) {
    p <- p + theme(axis.title.x = element_blank())
  } else {
    p <- p + labs(x = x.label)
  }
  p <- p + ggtitle(title) + labs(fill = legend.title) + theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text.x = element_text(angle = angle, hjust = 1, vjust = 0.5),
    legend.title = element_text(face = "bold")
  )
  if (rm.x.text) {
    p <- p + theme(axis.ticks.x = element_blank(),
                   axis.text.x = element_blank())
  }
  return(p)
}
